# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'C:\Users\Dan Gutchin\Desktop\final_prod\ui\untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QApplication, QMainWindow
import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from tensorflow import keras
import numpy as np
from pynput import keyboard
from time import time
import sys
import os
import threading
import collections

q = collections.deque()      #queue for the windows prediction calculation
dwell = []                   #The list of key dwell times 
startTimes = np.zeros(254)   #Saves the time in witch a key was pressed
startTyping = 0              #strat time
DownDown = []                #DownDown array
UpDown = []                  #UpDown array
virtualKeysID = []           #key ID array
lastKeyEnterdTime = 0        #a variable used to caclulate the duration between key strokes
count = 0                    #number of tuppels inserted 
model = None                 #keras model
sem = threading.Semaphore(0)    #semaphore to count the number of windows in the queue
mutex = threading.Semaphore(1)  #semaphore to protect the insert and pop operations on the queue
mainWindowclass = None          #the main ui calss


'''
Arguments: Key event

Algorithm: Calculates the time passed from previous pressed key to calculate DownDown,
and the new ID of the key = (keyID/254) 

returns: None
'''
def on_press(key):
    global lastKeyEnterdTime
    global startTyping
    global count
    currTime = time()

    if startTyping == 0:
        startTyping = currTime

    if lastKeyEnterdTime != 0:
        DownDown.append(currTime - lastKeyEnterdTime)
    lastKeyEnterdTime = currTime
    
    if hasattr(key, 'vk'):
        if startTimes[key.vk] == 0:
            startTimes[key.vk] = currTime
            virtualKeysID.append(key.vk/254)
            print(key.char,end='')

    else:
        if startTimes[key.value.vk] == 0:
           startTimes[key.value.vk] = currTime
           virtualKeysID.append(key.value.vk/254)
           print(key.value.char,end='')

    sys.stdout.flush()
    

'''
Arguments: Key event

Algorithm: Calculates the time passed from the same previous pressed key for the dwell time,
and puts into q the number of tuples already pressed by the user. 

returns: None
'''
def on_release(key):
    global count
    currTime = time()
    
    if hasattr(key, 'vk'):
        start = startTimes[key.vk]
        startTimes[key.vk] = 0
        
    else: 
        start = startTimes[key.value.vk]
        startTimes[key.value.vk] = 0
    dwell.append(currTime - start)
    
    
    if count > 30:
        mutex.acquire()
        q.append(count)
        mutex.release()
        sem.release()

    count+=1
    
    if key == keyboard.Key.esc:
        # Stop listener
        return False
    
'''
Arguments: Count - the number of tuples collected from the user up to this point.

Returns: Predict and prints the probability of a window from count-31 to count to be Dan. 
'''
def prepareAndSend(count) -> float:
    global dwell
    global DownDown
    global virtualKeysID
    global model

    dwellChunk = np.array(dwell[count-31:count])
    DownDownChunk = np.array(DownDown[count-31:count])
    UpDownChunk = DownDownChunk - dwellChunk

    finalVec = []

    index = count - 31
    for i in range(len(dwellChunk)-1):
        inputVector = (virtualKeysID[i+index],virtualKeysID[i+1+index],dwellChunk[i],dwellChunk[i+1],DownDownChunk[i],UpDownChunk[i])
        finalVec.append(inputVector)
    
    finalVec = np.array(finalVec)
    finalVec = finalVec.reshape(1,30,6)
    
    predictions = model.predict(x=finalVec,verbose= 1)
    for i in predictions:
        print(i)
    Ui_MainWindow.printTxt(mainWindowclass,i)

'''
**this function will run on a dedicated thread that will run until the end of the program**

Arguments: None

Algorithm: The thread will try to acquire sem wich will be sucsesfull only if the queue q is not empty
           then the thread needs to acquire the mutex to safly pop an item from q and after the thread 
           exits the critical section he can run the prediction method.

returns: None
'''
def predThread():
        while True:
                sem.acquire()
                mutex.acquire()
                x = q.popleft()
                mutex.release()
                prepareAndSend(x)


# The ui class nothing importent here except two functions -> Btn_clicked and printTxt
class Ui_MainWindow(object):

    # Creates the event listener for the keyboard and starts it, and creates the thread that will run the predictions
    def Btn_clicked(self):  
        listener =  keyboard.Listener(on_press=on_press,on_release=on_release)
        threading.Thread(target=predThread).start()
        listener.start()
        print("start")

    # Prints the predictions on the right window
    def printTxt(self,string):
        self.predText.insertPlainText("[" + str(self.c) +"] \n" + np.array2string(np.round(string[1],7)) + '\n')
        self.c+=1
        self.predText.moveCursor(QtGui.QTextCursor.End)
        if string[1] > 0.5:
            self.ansLable.setText("Dan")
        else:
            self.ansLable.setText("Not Dan")

    def setupUi(self, MainWindow):
        self.c=0
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1474, 967)
        MainWindow.setAutoFillBackground(False)
        MainWindow.setStyleSheet("background-color: rgb(235, 235, 235);")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setEnabled(True)
        self.label.setGeometry(QtCore.QRect(-10, 20, 1471, 61))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setTextFormat(QtCore.Qt.AutoText)
        self.label.setScaledContents(False)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setWordWrap(False)
        self.label.setObjectName("label")
        self.startBtn = QtWidgets.QPushButton(self.centralwidget)
        self.startBtn.setGeometry(QtCore.QRect(1280, 830, 131, 61))
        font = QtGui.QFont()
        font.setPointSize(20)
        font.setBold(False)
        font.setWeight(50)
        self.startBtn.setFont(font)
        self.startBtn.setFocusPolicy(QtCore.Qt.StrongFocus)
        self.startBtn.setStyleSheet("background-color: rgb(170, 255, 0);\n"
"border-color: rgb(0, 0, 0);")
        self.startBtn.setObjectName("startBtn")
        self.horizontalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(60, 280, 1351, 511))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.textInput = QtWidgets.QPlainTextEdit(self.horizontalLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(16)
        self.textInput.setFont(font)
        self.textInput.setAutoFillBackground(False)
        self.textInput.setStyleSheet("border-color: rgb(0, 0, 0);\n"
"background-color: rgb(255, 255, 255);")
        self.textInput.setLineWidth(0)
        self.textInput.setBackgroundVisible(False)
        self.textInput.setObjectName("textInput")
        self.horizontalLayout.addWidget(self.textInput)
        self.predText = QtWidgets.QTextBrowser(self.horizontalLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(16)
        self.predText.setFont(font)
        self.predText.setStyleSheet("border-color: rgb(0, 0, 0);\n"
"background-color: rgb(255, 255, 255);")
        self.predText.setObjectName("predText")
        self.horizontalLayout.addWidget(self.predText)
        self.horizontalLayout.setStretch(0, 1)
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(60, 140, 181, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        font.setBold(True)
        font.setUnderline(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(250, 140, 1011, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(1160, 230, 91, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        font.setBold(True)
        font.setUnderline(True)
        font.setWeight(75)
        self.label_4.setFont(font)
        self.label_4.setObjectName("label_4")
        self.ansLable = QtWidgets.QLabel(self.centralwidget)
        self.ansLable.setGeometry(QtCore.QRect(1260, 230, 121, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        font.setBold(True)
        font.setUnderline(False)
        font.setWeight(75)
        self.ansLable.setFont(font)
        self.ansLable.setObjectName("ansLable")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1474, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.predText.ensureCursorVisible()

        self.startBtn.clicked.connect(self.Btn_clicked) # Connect the buttun to the function

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Biokey test"))
        self.label.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:26pt; font-weight:600; text-decoration: underline;\">Biokey test app</span></p></body></html>"))
        self.startBtn.setText(_translate("MainWindow", "start"))
        self.label_2.setText(_translate("MainWindow", "Instructions:"))
        self.label_3.setText(_translate("MainWindow", "write some free text on the left window and see the predictions in the right window"))
        self.label_4.setText(_translate("MainWindow", "status:"))
        self.ansLable.setText(_translate("MainWindow", "Not dan"))




if __name__ == "__main__":

    
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    mainWindowclass = ui
    ui.setupUi(MainWindow)
    MainWindow.show()
    model = keras.models.load_model(r'C:\Users\Dan Gutchin\Desktop\final_prod\ui\1D_2XLSTM32_1x1_Dan_150epochs_WS30.h5')
    sys.exit(app.exec_())
